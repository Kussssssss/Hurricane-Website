import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import time
from data_processing import HurricaneDataProcessor
import os
import pickle
import folium
from streamlit_folium import st_folium

# C·∫•u h√¨nh trang
st.set_page_config(
    page_title="Ph√¢n t√≠ch qu·ªπ ƒë·∫°o b√£o v√† d·ª± ƒëo√°n",
    page_icon="üåÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #1E88E5;
        text-align: center;
        margin-bottom: 1rem;
    }
    .sub-header {
        font-size: 1.8rem;
        color: #0D47A1;
        margin-top: 2rem;
        margin-bottom: 1rem;
    }
    .card {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    .metric-value {
        font-size: 2rem;
        font-weight: bold;
        color: #1E88E5;
    }
    .metric-label {
        font-size: 1rem;
        color: #616161;
    }
    .category-0 { color: blue; }
    .category-1 { color: green; }
    .category-2 { color: red; }
    .category-3 { color: purple; }
    .category-4 { color: orange; }
    .category-5 { color: brown; }
</style>
""", unsafe_allow_html=True)

# Kh·ªüi t·∫°o session state
if 'processor' not in st.session_state:
    st.session_state.processor = HurricaneDataProcessor()
    st.session_state.data_loaded = False
    st.session_state.features_extracted = False
    st.session_state.model_trained = False
    st.session_state.selected_trajectory = None
    st.session_state.animation_speed = 50
    st.session_state.animation_frame = 0
    st.session_state.show_animation = False
    st.session_state.preprocessing_options = {
        'outlier_method': 'winsorize',
        'create_interactions': True,
        'use_features': True
    }

# --- Helper: Chuy·ªÉn DataFrame sang ƒë·ªãnh d·∫°ng Arrow-compatible ---
def make_dataframe_arrow_compatible(df):
    for col in df.columns:
        if df[col].dtype == 'object':
            non_null = df[col].dropna()
            if not non_null.empty:
                sample = non_null.iloc[0]
                if isinstance(sample, (list, np.ndarray)):
                    df[col] = df[col].apply(lambda x: np.mean(x) if isinstance(x, (list, np.ndarray)) else x)
    return df

# --- C√°c h√†m x·ª≠ l√Ω d·ªØ li·ªáu ---
@st.cache_resource
def load_data():
    processor = st.session_state.processor
    dataset = processor.load_data()
    st.session_state.data_loaded = True
    return dataset

@st.cache_data
def extract_features(_use_features=True, _outlier_method='winsorize', _create_interactions=True):
    processor = st.session_state.processor
    
    if _use_features:
        features_df = processor.process_data_pipeline(
            outlier_method=_outlier_method,
            create_interactions=_create_interactions
        )
    else:
        features_df = processor.extract_features()
    
    st.session_state.features_extracted = True
    
    return make_dataframe_arrow_compatible(features_df)

@st.cache_resource
def train_model(_use_features=True):
    processor = st.session_state.processor    
    model_results = processor.train_model(
        use_features=_use_features
    )
    
    st.session_state.model_trained = True
    processor.save_model()
    return model_results

# --- C√°c h√†m tr·ª±c quan h√≥a ---
def create_trajectory_map(trajectories, labels, sample_size=50):
    if len(trajectories) > sample_size:
        indices = np.random.choice(len(trajectories), sample_size, replace=False)
        sample_trajs = [trajectories[i] for i in indices]
        sample_labels = [labels[i] for i in indices]
    else:
        sample_trajs = trajectories
        sample_labels = labels

    df_points = []
    for i, traj in enumerate(sample_trajs):
        category = sample_labels[i]
        for j in range(len(traj.r)):
            df_points.append({
                'traj_id': traj.traj_id,
                'point_id': j,
                'longitude': traj.r[j, 0],
                'latitude': traj.r[j, 1],
                'category': category,
                'time_step': j
            })
    df = pd.DataFrame(df_points)
    fig = px.line_geo(
        df, 
        lat='latitude', 
        lon='longitude',
        color='category',
        color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
        line_group='traj_id',
        title='Qu·ªπ ƒë·∫°o b√£o theo lo·∫°i'
    )
    start_points = df[df['point_id'] == 0]
    fig.add_trace(
        go.Scattergeo(
            lat=start_points['latitude'],
            lon=start_points['longitude'],
            mode='markers',
            marker=dict(size=6, color=start_points['category'],
                        colorscale=['blue', 'green', 'red', 'purple', 'orange', 'brown']),
            name='ƒêi·ªÉm kh·ªüi ƒë·∫ßu'
        )
    )
    fig.update_layout(
        height=600,
        legend_title_text='Lo·∫°i b√£o',
        geo=dict(
            showland=True,
            landcolor='rgb(217, 217, 217)',
            coastlinecolor='rgb(37, 102, 142)',
            countrycolor='rgb(217, 217, 217)',
            showocean=True,
            oceancolor='rgb(204, 229, 255)',
            showlakes=True,
            lakecolor='rgb(204, 229, 255)',
            showrivers=True,
            rivercolor='rgb(204, 229, 255)'
        )
    )
    return fig, df

def create_animated_trajectory_map(df):
    # T√≠ch l≈©y c√°c ƒëi·ªÉm: v·ªõi m·ªói frame f, hi·ªÉn th·ªã c√°c ƒëi·ªÉm c√≥ time_step <= f
    max_frame = int(df['time_step'].max())
    df_list = []
    for f in range(max_frame + 1):
        temp = df[df['time_step'] <= f].copy()
        temp['frame'] = f
        df_list.append(temp)
    df_accumulated = pd.concat(df_list)
    
    fig = px.line_geo(
        df_accumulated, 
        lat='latitude', 
        lon='longitude',
        color='category',
        color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
        line_group='traj_id',
        animation_frame='frame',
        title='Animation qu·ªπ ƒë·∫°o b√£o'
    )
    fig.update_layout(
        height=600,
        legend_title_text='Lo·∫°i b√£o',
        geo=dict(
            showland=True,
            landcolor='rgb(217, 217, 217)',
            coastlinecolor='rgb(37, 102, 142)',
            countrycolor='rgb(217, 217, 217)',
            showocean=True,
            oceancolor='rgb(204, 229, 255)',
            showlakes=True,
            lakecolor='rgb(204, 229, 255)',
            showrivers=True,
            rivercolor='rgb(204, 229, 255)'
        ),
        updatemenus=[{
            'type': 'buttons',
            'showactive': False,
            'buttons': [
                {
                    'label': 'Play',
                    'method': 'animate',
                    'args': [None, {'frame': {'duration': 100, 'redraw': True}, 'fromcurrent': True}]
                },
                {
                    'label': 'Pause',
                    'method': 'animate',
                    'args': [[None], {'frame': {'duration': 0, 'redraw': False}, 'mode': 'immediate', 'transition': {'duration': 0}}]
                }
            ],
            'direction': 'left',
            'pad': {'r': 10, 't': 10},
            'x': 0.1,
            'y': 0
        }]
    )
    return fig

def create_3d_trajectory_plot(trajectories, labels, sample_size=20):
    if len(trajectories) > sample_size:
        indices = np.random.choice(len(trajectories), sample_size, replace=False)
        sample_trajs = [trajectories[i] for i in indices]
        sample_labels = [labels[i] for i in indices]
    else:
        sample_trajs = trajectories
        sample_labels = labels

    df_points = []
    for i, traj in enumerate(sample_trajs):
        category = sample_labels[i]
        for j in range(len(traj.r)):
            time_pct = j / (len(traj.r)-1) if len(traj.r) > 1 else 0
            df_points.append({
                'traj_id': traj.traj_id,
                'point_id': j,
                'longitude': traj.r[j, 0],
                'latitude': traj.r[j, 1],
                'time': time_pct,
                'category': category
            })
    df = pd.DataFrame(df_points)
    fig = px.line_3d(
        df,
        x='longitude',
        y='latitude',
        z='time',
        color='category',
        color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
        line_group='traj_id',
        title='3D Qu·ªπ ƒë·∫°o b√£o (tr·ª•c Z: th·ªùi gian chu·∫©n h√≥a)'
    )
    start_points = df[df['point_id'] == 0]
    fig.add_trace(
        go.Scatter3d(
            x=start_points['longitude'],
            y=start_points['latitude'],
            z=start_points['time'],
            mode='markers',
            marker=dict(size=4, color=start_points['category'],
                        colorscale=['blue', 'green', 'red', 'purple', 'orange', 'brown']),
            name='ƒêi·ªÉm kh·ªüi ƒë·∫ßu'
        )
    )
    fig.update_layout(
        height=700,
        scene=dict(
            xaxis_title='Kinh ƒë·ªô',
            yaxis_title='Vƒ© ƒë·ªô',
            zaxis_title='Th·ªùi gian (chu·∫©n h√≥a)',
            aspectmode='manual',
            aspectratio=dict(x=1.5, y=1, z=0.5)
        )
    )
    return fig

def create_velocity_profile(trajectories, labels, sample_size=10):
    if len(trajectories) > sample_size:
        indices = np.random.choice(len(trajectories), sample_size, replace=False)
        sample_trajs = [trajectories[i] for i in indices]
        sample_labels = [labels[i] for i in indices]
    else:
        sample_trajs = trajectories
        sample_labels = labels

    fig = make_subplots(rows=len(sample_trajs), cols=1, 
                        shared_xaxes=True,
                        subplot_titles=[f'Trajectory {traj.traj_id} (Lo·∫°i {label})' 
                                        for traj, label in zip(sample_trajs, sample_labels)])
    category_colors = {0: 'blue', 1: 'green', 2: 'red', 3: 'purple', 4: 'orange', 5: 'brown'}
    for i, (traj, label) in enumerate(zip(sample_trajs, sample_labels)):
        try:
            v_magnitude = np.sqrt(np.sum(traj.v**2, axis=1))
            time_pct = np.linspace(0, 100, len(v_magnitude))
            fig.add_trace(
                go.Scatter(
                    x=time_pct,
                    y=v_magnitude,
                    mode='lines',
                    line=dict(color=category_colors.get(label, 'gray'), width=2),
                    name=f'Lo·∫°i {label}'
                ),
                row=i+1, col=1
            )
            mean_v = np.mean(v_magnitude)
            fig.add_trace(
                go.Scatter(
                    x=[0, 100],
                    y=[mean_v, mean_v],
                    mode='lines',
                    line=dict(color='black', width=1, dash='dash'),
                    name='V·∫≠n t·ªëc trung b√¨nh',
                    showlegend=False
                ),
                row=i+1, col=1
            )
        except ValueError:
            continue
    fig.update_layout(
        height=100 * len(sample_trajs),
        title='Bi·ªÉu ƒë·ªì v·∫≠n t·ªëc c·ªßa qu·ªπ ƒë·∫°o b√£o',
        showlegend=True
    )
    for i in range(len(sample_trajs)):
        fig.update_yaxes(title_text='V·∫≠n t·ªëc', row=i+1, col=1)
    fig.update_xaxes(title_text='Ti·∫øn tr√¨nh trajectory (%)', row=len(sample_trajs), col=1)
    return fig
# --- H√†m t√≠nh kho·∫£ng c√°ch theo Haversine ---
def haversine(lon1, lat1, lon2, lat2):
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = np.sin(dlat/2)**2 + np.cos(lat1)*np.cos(lat2)*np.sin(dlon/2)**2
    c = 2 * np.arcsin(np.sqrt(a))
    r = 6371  # b√°n k√≠nh Tr√°i ƒë·∫•t km
    return c * r

# --- Trang d·ª± ƒëo√°n qua v·∫Ω ƒë∆∞·ªùng ƒëi c·ªßa b√£o ---
def show_drawing_prediction():
    st.title("D·ª± ƒëo√°n lo·∫°i b√£o t·ª´ ƒë∆∞·ªùng v·∫Ω")
    st.write("Tr√™n b·∫£n ƒë·ªì d∆∞·ªõi ƒë√¢y, h√£y s·ª≠ d·ª•ng c√¥ng c·ª• v·∫Ω (Polyline) ƒë·ªÉ v·∫Ω ƒë∆∞·ªùng ƒëi c·ªßa b√£o quanh khu v·ª±c ch√¢u M·ªπ.")
    
    # T·∫°o b·∫£n ƒë·ªì v·ªõi folium, trung t√¢m ch√¢u M·ªπ
    m = folium.Map(location=[37, -95], zoom_start=4)
    draw = folium.plugins.Draw(
        export=True,
        draw_options={
            'polyline': True,
            'polygon': False,
            'circle': False,
            'rectangle': False,
            'marker': False,
            'circlemarker': False
        }
    )
    draw.add_to(m)
    output = st_folium(m, width=700, height=500)
    
    if output and output.get('last_active_drawing'):
        geojson = output['last_active_drawing']
        if geojson['geometry']['type'] == 'LineString':
            coords = geojson['geometry']['coordinates']  # [ [lon, lat], ... ]
            st.subheader("ƒê∆∞·ªùng b·∫°n v·∫Ω:")
            st.write(coords)
            
            # T√≠nh c√°c ƒë·∫∑c tr∆∞ng t·ª´ ƒë∆∞·ªùng v·∫Ω:
            # Gi·∫£ s·ª≠ th·ªùi gian gi·ªØa c√°c ƒëi·ªÉm l√† 1 gi·ªù
            total_distance = 0
            speeds = []
            lons = []
            lats = []
            for i in range(len(coords)-1):
                lon1, lat1 = coords[i]
                lon2, lat2 = coords[i+1]
                d = haversine(lon1, lat1, lon2, lat2)
                total_distance += d
                speeds.append(d)  # km/h
                lons.extend([lon1, lon2])
                lats.extend([lat1, lat2])
            average_speed = np.mean(speeds) if speeds else 0
            max_speed = np.max(speeds) if speeds else 0
            lon_range = max(lons) - min(lons) if lons else 0
            lat_range = max(lats) - min(lats) if lats else 0
            
            st.write(f"**T·ªïng qu√£ng ƒë∆∞·ªùng:** {total_distance:.2f} km")
            st.write(f"**V·∫≠n t·ªëc trung b√¨nh:** {average_speed:.2f} km/h")
            st.write(f"**V·∫≠n t·ªëc t·ªëi ƒëa:** {max_speed:.2f} km/h")
            st.write(f"**Kho·∫£ng c√°ch kinh ƒë·ªô:** {lon_range:.2f} ƒë·ªô")
            st.write(f"**Kho·∫£ng c√°ch vƒ© ƒë·ªô:** {lat_range:.2f} ƒë·ªô")
            
            # T·∫°o vector ƒë·∫∑c tr∆∞ng: gi·∫£ s·ª≠ m√¥ h√¨nh y√™u c·∫ßu c√°c ƒë·∫∑c tr∆∞ng n√†y
            feature_vector = np.array([total_distance, average_speed, max_speed, lon_range, lat_range]).reshape(1, -1)
            st.write("Vector ƒë·∫∑c tr∆∞ng:")
            st.write(feature_vector)
            
            # D·ª± ƒëo√°n lo·∫°i b√£o (gi·∫£ s·ª≠ m√¥ h√¨nh ƒë√£ ƒë∆∞·ª£c hu·∫•n luy·ªán v√† l∆∞u trong processor.model)
            try:
                prediction = st.session_state.processor.model.predict(feature_vector)[0]
                st.success(f"D·ª± ƒëo√°n lo·∫°i b√£o: {prediction}")
            except Exception as e:
                st.error(f"L·ªói khi d·ª± ƒëo√°n: {e}")
            
            # Hi·ªÉn th·ªã ƒë∆∞·ªùng v·∫Ω l√™n b·∫£n ƒë·ªì (s·ª≠ d·ª•ng folium)
            m2 = folium.Map(location=[np.mean(lats), np.mean(lons)], zoom_start=5)
            folium.PolyLine(locations=[(lat, lon) for lon, lat in coords], color='red', weight=3).add_to(m2)
            st.subheader("ƒê∆∞·ªùng v·∫Ω tr√™n b·∫£n ƒë·ªì:")
            st_folium(m2, width=700, height=500)
        else:
            st.error("Vui l√≤ng v·∫Ω m·ªôt ƒë∆∞·ªùng polyline.")
    else:
        st.info("Vui l√≤ng v·∫Ω ƒë∆∞·ªùng ƒëi c·ªßa b√£o tr√™n b·∫£n ƒë·ªì.")

def create_feature_importance_plot(model_results):
    feature_importance = model_results['feature_importance']
    fig = px.bar(
        feature_importance.head(10),
        x='importance',
        y='feature',
        orientation='h',
        color='importance',
        color_continuous_scale='Blues',
        title='Top 10 T·∫ßm quan tr·ªçng c·ªßa ƒë·∫∑c tr∆∞ng cho d·ª± ƒëo√°n lo·∫°i b√£o'
    )
    fig.update_layout(
        xaxis_title='T·∫ßm quan tr·ªçng',
        yaxis_title='ƒê·∫∑c tr∆∞ng',
        height=500
    )
    return fig

def create_confusion_matrix_plot(model_results):
    cm = model_results['confusion_matrix']
    categories = sorted(set(model_results['y_test']))
    labels = [f'Lo·∫°i {cat}' for cat in categories]
    fig = px.imshow(
        cm,
        x=labels,
        y=labels,
        color_continuous_scale='Blues',
        labels=dict(x='D·ª± ƒëo√°n', y='Th·∫≠t', color='S·ªë l∆∞·ª£ng'),
        title='Ma tr·∫≠n nh·∫ßm l·∫´n'
    )
    for i in range(len(cm)):
        for j in range(len(cm[i])):
            fig.add_annotation(
                x=labels[j],
                y=labels[i],
                text=str(cm[i, j]),
                showarrow=False,
                font=dict(color='white' if cm[i, j] > cm.max()/2 else 'black')
            )
    fig.update_layout(height=500)
    return fig

def create_feature_distribution_plot(features_df, feature_name):
    fig = px.box(
        features_df,
        x='category',
        y=feature_name,
        color='category',
        color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
        title=f'Ph√¢n ph·ªëi {feature_name} theo lo·∫°i b√£o',
        labels={'category': 'Lo·∫°i b√£o', feature_name: feature_name.replace('_', ' ').title()}
    )
    fig.update_layout(height=500)
    return fig

def create_normalized_trajectory_plot(processor, category=None):
    samples = processor.get_sample_trajectories(n_per_category=10)
    fig = make_subplots(
        rows=2, cols=3,
        subplot_titles=[f'Lo·∫°i {cat}' for cat in sorted(samples.keys())],
        specs=[[{'type': 'xy'}, {'type': 'xy'}, {'type': 'xy'}],
               [{'type': 'xy'}, {'type': 'xy'}, {'type': 'xy'}]]
    )
    for i, cat in enumerate(sorted(samples.keys())):
        row = i // 3 + 1
        col = i % 3 + 1
        if category is not None and cat != category:
            continue
        for traj in samples[cat]:
            if len(traj) >= 3:
                r_norm = processor.normalize_trajectory(traj)
                fig.add_trace(
                    go.Scatter(
                        x=r_norm[:, 0],
                        y=r_norm[:, 1],
                        mode='lines',
                        line=dict(color=processor.get_category_color(cat), width=1.5),
                        opacity=0.7,
                        showlegend=False
                    ),
                    row=row, col=col
                )
                fig.add_trace(
                    go.Scatter(
                        x=[0],
                        y=[0],
                        mode='markers',
                        marker=dict(color='black', size=6),
                        showlegend=False
                    ),
                    row=row, col=col
                )
        fig.update_xaxes(title_text='X chu·∫©n h√≥a', row=row, col=col, zeroline=True, zerolinewidth=1, zerolinecolor='gray')
        fig.update_yaxes(title_text='Y chu·∫©n h√≥a', row=row, col=col, zeroline=True, zerolinewidth=1, zerolinecolor='gray')
    fig.update_layout(
        height=700,
        title='Qu·ªπ ƒë·∫°o chu·∫©n h√≥a theo lo·∫°i b√£o',
        showlegend=False
    )
    return fig

def create_hurricane_impact_visualization(features_df):
    if 'impact_score' in features_df.columns:
        fig = px.histogram(features_df, x='impact_score', color='category', 
                           color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
                           title='Ph√¢n b·ªë Impact Score theo lo·∫°i b√£o')
    else:
        fig = px.histogram(features_df, x='traj_duration', color='category', 
                           color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
                           title='Ph√¢n b·ªë Th·ªùi l∆∞·ª£ng trajectory theo lo·∫°i b√£o')
    fig.update_layout(height=500)
    return fig

# --- C√°c h√†m giao di·ªán d·ª± ƒëo√°n d·ªØ li·ªáu ƒë·∫ßu v√†o th·ª±c t·∫ø ---
def show_real_input_prediction():
    st.title("D·ª± ƒëo√°n t·ª´ d·ªØ li·ªáu ƒë·∫ßu v√†o th·ª±c t·∫ø")
    st.write("T·∫£i l√™n file CSV ch·ª©a d·ªØ li·ªáu trajectory v·ªõi c√°c c·ªôt: t, longitude, latitude")
    uploaded_file = st.file_uploader("Ch·ªçn file CSV", type=["csv"])
    if uploaded_file is not None:
        try:
            df_input = pd.read_csv(uploaded_file)
            st.subheader("D·ªØ li·ªáu ƒë·∫ßu v√†o:")
            st.dataframe(df_input)
            # T·∫°o ƒë·ªëi t∆∞·ª£ng trajectory t·ª´ d·ªØ li·ªáu CSV
            # Gi·∫£ s·ª≠ file CSV c√≥ c√°c c·ªôt: t, longitude, latitude
            traj_input = type("Trajectory", (object,), {})()
            traj_input.t = df_input["t"].values
            traj_input.r = df_input[["longitude", "latitude"]].values
            # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu trajectory th√†nh vector ƒë·∫∑c tr∆∞ng s·ª≠ d·ª•ng featurizer c·ªßa m√¥ h√¨nh
            features = st.session_state.processor.model.featurizer.transform(traj_input)
            prediction = st.session_state.processor.model.predict([features])[0]
            st.success(f"D·ª± ƒëo√°n lo·∫°i b√£o: {prediction}")
            # Hi·ªÉn th·ªã trajectory l√™n b·∫£n ƒë·ªì
            fig, _ = create_trajectory_map([traj_input], [prediction], sample_size=1)
            st.plotly_chart(fig, use_container_width=True)
        except Exception as e:
            st.error(f"L·ªói x·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫ßu v√†o: {e}")

# --- C√°c trang giao di·ªán ch√≠nh ---
def show_home_page():
    st.title("Ph√¢n t√≠ch qu·ªπ ƒë·∫°o b√£o v√† d·ª± ƒëo√°n")
    st.write("""
    Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ·ª©ng d·ª•ng ph√¢n t√≠ch qu·ªπ ƒë·∫°o b√£o v√† d·ª± ƒëo√°n lo·∫°i b√£o. Dashboard n√†y cho ph√©p b·∫°n kh√°m ph√° d·ªØ li·ªáu qu·ªπ ƒë·∫°o b√£o,
    tr·ª±c quan h√≥a c√°c m·∫´u v√† d·ª± ƒëo√°n lo·∫°i b√£o d·ª±a tr√™n ƒë·∫∑c tr∆∞ng qu·ªπ ƒë·∫°o.
    """)
    st.header("T·ªïng quan d·ªØ li·ªáu")
    if not st.session_state.data_loaded:
        st.info("Vui l√≤ng load d·ªØ li·ªáu b√£o b·∫±ng n√∫t ·ªü thanh b√™n.")
    else:
        processor = st.session_state.processor
        summary = processor.get_dataset_summary()
        col1, col2 = st.columns(2)
        with col1:
            st.subheader("Th·ªëng k√™ d·ªØ li·ªáu")
            st.write(f"**T√™n dataset:** {summary['dataset_name']}")
            st.write(f"**T·ªïng s·ªë trajectory:** {summary['total_trajectories']}")
            st.write(f"**S·ªë lo·∫°i b√£o:** {summary['classes']}")
            st.write(f"**ƒê·ªô d√†i trajectory:** t·ª´ {summary['min_trajectory_length']} ƒë·∫øn {summary['max_trajectory_length']} ƒëi·ªÉm (trung b√¨nh: {summary['avg_trajectory_length']:.2f})")
            st.write(f"**Th·ªùi l∆∞·ª£ng trajectory:** t·ª´ {summary['min_duration_hours']:.2f} ƒë·∫øn {summary['max_duration_hours']:.2f} gi·ªù (trung b√¨nh: {summary['avg_duration_hours']:.2f})")
        with col2:
            st.subheader("Ph√¢n b·ªë lo·∫°i b√£o")
            category_counts = summary['class_distribution']
            df_categories = pd.DataFrame({
                'Lo·∫°i': list(category_counts.keys()),
                'S·ªë l∆∞·ª£ng': list(category_counts.values())
            })
            df_categories['Ph·∫ßn trƒÉm'] = df_categories['S·ªë l∆∞·ª£ng'] / df_categories['S·ªë l∆∞·ª£ng'].sum() * 100
            fig = px.bar(
                df_categories,
                x='Lo·∫°i',
                y='S·ªë l∆∞·ª£ng',
                color='Lo·∫°i',
                color_discrete_sequence=['blue', 'green', 'red', 'purple', 'orange', 'brown'],
                text='Ph·∫ßn trƒÉm',
                labels={'Ph·∫ßn trƒÉm': '%'},
                title='Ph√¢n b·ªë lo·∫°i b√£o'
            )
            fig.update_traces(texttemplate='%{text:.1f}%', textposition='outside')
            st.plotly_chart(fig, use_container_width=True)
    st.header("C√°c m·ª•c trong ·ª©ng d·ª•ng")
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("Tr√¨nh duy·ªát qu·ªπ ƒë·∫°o")
        st.write("Tr·ª±c quan h√≥a qu·ªπ ƒë·∫°o b√£o tr√™n b·∫£n ƒë·ªì t∆∞∆°ng t√°c v√† kh√°m ph√° ph√¢n b·ªë ƒë·ªãa l√Ω theo lo·∫°i.")
        st.subheader("Ph√¢n t√≠ch ƒë·∫∑c tr∆∞ng")
        st.write("Ph√¢n t√≠ch c√°c ƒë·∫∑c tr∆∞ng (v·∫≠n t·ªëc, ƒë·ªô d√†i, th·ªùi l∆∞·ª£ng, v.v.) v√† kh√°m ph√° m·ªëi t∆∞∆°ng quan.")
    with col2:
        st.subheader("M√¥ h√¨nh d·ª± ƒëo√°n")
        st.write("D·ª± ƒëo√°n lo·∫°i b√£o d·ª±a tr√™n ƒë·∫∑c tr∆∞ng qu·ªπ ƒë·∫°o v√† ƒë√°nh gi√° hi·ªáu nƒÉng m√¥ h√¨nh.")
        st.subheader("So s√°nh qu·ªπ ƒë·∫°o")
        st.write("So s√°nh qu·ªπ ƒë·∫°o chu·∫©n h√≥a gi·ªØa c√°c lo·∫°i b√£o.")

def show_trajectory_explorer():
    st.title("Tr√¨nh duy·ªát qu·ªπ ƒë·∫°o b√£o")
    if not st.session_state.data_loaded:
        st.info("Vui l√≤ng load d·ªØ li·ªáu b√£o b·∫±ng n√∫t ·ªü thanh b√™n.")
        return
    processor = st.session_state.processor
    st.sidebar.header("B·ªô l·ªçc")
    categories = sorted(processor.dataset.classes)
    selected_categories = st.sidebar.multiselect(
        "Ch·ªçn lo·∫°i b√£o",
        options=categories,
        default=categories
    )
    sample_size = st.sidebar.slider(
        "K√≠ch th∆∞·ªõc m·∫´u",
        min_value=10,
        max_value=200,
        value=50,
        step=10
    )
    filtered_indices = [i for i, label in enumerate(processor.dataset.labels) if label in selected_categories]
    filtered_trajs = [processor.dataset.trajs[i] for i in filtered_indices]
    filtered_labels = [processor.dataset.labels[i] for i in filtered_indices]
    st.write(f"Hi·ªÉn th·ªã {min(sample_size, len(filtered_trajs))} trajectory tr√™n t·ªïng s·ªë {len(filtered_trajs)} trajectory ƒë√£ l·ªçc.")
    with st.spinner("T·∫°o b·∫£n ƒë·ªì qu·ªπ ƒë·∫°o..."):
        fig, _ = create_trajectory_map(filtered_trajs, filtered_labels, sample_size)
        st.plotly_chart(fig, use_container_width=True)
    st.header("Th·ªëng k√™ trajectory theo lo·∫°i")
    if st.session_state.features_extracted:
        features_df = st.session_state.processor.features_df.copy()
        features_df = make_dataframe_arrow_compatible(features_df)
        filtered_features = features_df[features_df['category'].isin(selected_categories)]
        grouped = filtered_features.groupby('category').agg({
            'traj_length': ['mean', 'min', 'max'],
            'traj_duration': ['mean', 'min', 'max'],
            'mean_velocity': ['mean', 'min', 'max'],
            'lon_range': ['mean', 'min', 'max'],
            'lat_range': ['mean', 'min', 'max']
        }).reset_index()
        grouped.columns = ['_'.join(col).strip('_') for col in grouped.columns.values]
        grouped = make_dataframe_arrow_compatible(grouped)
        st.dataframe(grouped)
    else:
        st.info("Vui l√≤ng tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng ƒë·ªÉ xem th·ªëng k√™ trajectory.")

def show_feature_analysis():
    st.title("Ph√¢n t√≠ch ƒë·∫∑c tr∆∞ng b√£o")
    if not st.session_state.features_extracted:
        st.info("Vui l√≤ng tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng b·∫±ng n√∫t ·ªü thanh b√™n.")
        return
    processor = st.session_state.processor
    features_df = st.session_state.processor.features_df.copy()
    features_df = make_dataframe_arrow_compatible(features_df)
    st.sidebar.header("Ch·ªçn ƒë·∫∑c tr∆∞ng")
    feature_options = [col for col in features_df.columns if col not in ['traj_id', 'category']]
    selected_feature = st.sidebar.selectbox(
        "Ch·ªçn ƒë·∫∑c tr∆∞ng c·∫ßn ph√¢n t√≠ch",
        options=feature_options,
        index=feature_options.index('mean_velocity') if 'mean_velocity' in feature_options else 0
    )
    st.header(f"Ph√¢n ph·ªëi {selected_feature} theo lo·∫°i b√£o")
    with st.spinner("T·∫°o bi·ªÉu ƒë·ªì ph√¢n ph·ªëi..."):
        fig = create_feature_distribution_plot(features_df, selected_feature)
        st.plotly_chart(fig, use_container_width=True)
    st.header("Ma tr·∫≠n t∆∞∆°ng quan c·ªßa ƒë·∫∑c tr∆∞ng")
    correlation_features = st.multiselect(
        "Ch·ªçn c√°c ƒë·∫∑c tr∆∞ng ƒë·ªÉ ph√¢n t√≠ch t∆∞∆°ng quan",
        options=feature_options,
        default=feature_options[:5]
    )
    if correlation_features:
        corr_df = features_df[correlation_features + ['category']]
        corr_matrix = corr_df[correlation_features].corr()
        fig, ax = plt.subplots(figsize=(10, 8))
        sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f', ax=ax)
        ax.set_title('Ma tr·∫≠n t∆∞∆°ng quan c·ªßa ƒë·∫∑c tr∆∞ng')
        st.pyplot(fig)
    if st.session_state.model_trained:
        st.header("T·∫ßm quan tr·ªçng c·ªßa ƒë·∫∑c tr∆∞ng trong d·ª± ƒëo√°n lo·∫°i b√£o")
        model_results = train_model()
        with st.spinner("T·∫°o bi·ªÉu ƒë·ªì t·∫ßm quan tr·ªçng..."):
            fig = create_feature_importance_plot(model_results)
            st.plotly_chart(fig, use_container_width=True)

def show_prediction_model():
    st.title("M√¥ h√¨nh d·ª± ƒëo√°n lo·∫°i b√£o")
    if not st.session_state.model_trained:
        st.info("Vui l√≤ng hu·∫•n luy·ªán m√¥ h√¨nh b·∫±ng n√∫t ·ªü thanh b√™n.")
        return
    processor = st.session_state.processor
    model_results = train_model()
    st.header("Hi·ªáu nƒÉng c·ªßa m√¥ h√¨nh")
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("B√°o c√°o ph√¢n lo·∫°i")
        report = model_results['report']
        report_df = pd.DataFrame(report).transpose()
        st.dataframe(report_df)
    with col2:
        st.subheader("Ma tr·∫≠n nh·∫ßm l·∫´n")
        fig_cm = create_confusion_matrix_plot(model_results)
        st.plotly_chart(fig_cm, use_container_width=True)
    st.header("T·∫ßm quan tr·ªçng c·ªßa ƒë·∫∑c tr∆∞ng")
    fig_fi = create_feature_importance_plot(model_results)
    st.plotly_chart(fig_fi, use_container_width=True)
    st.header("D·ª± ƒëo√°n lo·∫°i b√£o cho qu·ªπ ƒë·∫°o m·ªõi")
    uploaded_file = st.file_uploader("T·∫£i l√™n file d·ªØ li·ªáu qu·ªπ ƒë·∫°o m·ªõi (pickle ho·∫∑c CSV)", type=["pkl", "csv"])
    if uploaded_file is not None:
        try:
            if uploaded_file.name.endswith("pkl"):
                new_data = pickle.load(uploaded_file)
            else:
                new_data = pd.read_csv(uploaded_file)
            # Gi·∫£ s·ª≠ new_data ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω t∆∞∆°ng t·ª± nh∆∞ d·ªØ li·ªáu hu·∫•n luy·ªán
            features = st.session_state.processor.model.featurizer.transform(new_data)
            prediction = st.session_state.processor.model.predict([features])[0]
            st.success(f"D·ª± ƒëo√°n lo·∫°i b√£o: {prediction}")
        except Exception as e:
            st.error(f"L·ªói trong qu√° tr√¨nh d·ª± ƒëo√°n: {e}")
    st.header("D·ª± ƒëo√°n qu·ªπ ƒë·∫°o ·∫£o t·ª´ t·∫≠p ki·ªÉm tra")
    if st.session_state.data_loaded:
        dataset = st.session_state.processor.dataset if hasattr(st.session_state.processor, "dataset") else load_data()
        idx = st.number_input("Ch·ªçn s·ªë th·ª© t·ª± c·ªßa trajectory trong t·∫≠p ki·ªÉm tra", 
                              min_value=0, max_value=len(dataset.trajs)-1, value=0, step=1)
        traj_ao = dataset.trajs[idx]
        groundtruth = dataset.labels[idx]
        try:
            # S·ª≠ d·ª•ng d·ªØ li·ªáu th·ª±c t·∫ø c·ªßa trajectory ƒë·ªÉ chuy·ªÉn ƒë·ªïi th√†nh vector ƒë·∫∑c tr∆∞ng
            features = st.session_state.processor.model.featurizer.transform(traj_ao)
            pred_ao = st.session_state.processor.model.predict([features])[0]
        except Exception as e:
            pred_ao = f"L·ªói: {e}"
        st.write(f"**Nh√£n th·ª±c t·∫ø:** {groundtruth}")
        st.write(f"**Nh√£n d·ª± ƒëo√°n:** {pred_ao}")
        fig_ao, _ = create_trajectory_map([traj_ao], [groundtruth], sample_size=1)
        st.plotly_chart(fig_ao, use_container_width=True)

def show_trajectory_comparison():
    st.title("So s√°nh qu·ªπ ƒë·∫°o b√£o")
    if not st.session_state.data_loaded:
        st.info("Vui l√≤ng load d·ªØ li·ªáu b√£o b·∫±ng n√∫t ·ªü thanh b√™n.")
        return
    processor = st.session_state.processor
    categories = sorted(processor.dataset.classes)
    selected_category = st.selectbox("Ch·ªçn lo·∫°i b√£o ƒë·ªÉ so s√°nh", options=["T·∫•t c·∫£"] + categories)
    st.header("So s√°nh qu·ªπ ƒë·∫°o chu·∫©n h√≥a")
    with st.spinner("T·∫°o bi·ªÉu ƒë·ªì qu·ªπ ƒë·∫°o chu·∫©n h√≥a..."):
        fig = create_normalized_trajectory_plot(processor, None if selected_category == "T·∫•t c·∫£" else selected_category)
        st.plotly_chart(fig, use_container_width=True)

def show_hurricane_impact():
    st.title("Tr·ª±c quan h√≥a t√°c ƒë·ªông b√£o")
    if not st.session_state.features_extracted:
        st.info("Vui l√≤ng tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng ƒë·ªÉ xem tr·ª±c quan h√≥a t√°c ƒë·ªông b√£o.")
        return
    processor = st.session_state.processor
    features_df = processor.features_df.copy()
    features_df = make_dataframe_arrow_compatible(features_df)
    fig = create_hurricane_impact_visualization(features_df)
    st.plotly_chart(fig, use_container_width=True)

def show_advanced_visualizations():
    st.title("Tr·ª±c quan h√≥a n√¢ng cao")
    processor = st.session_state.processor
    if not st.session_state.data_loaded:
        st.info("Vui l√≤ng load d·ªØ li·ªáu b√£o.")
        return
    dataset = processor.dataset
    st.subheader("Animation Qu·ªπ ƒë·∫°o b√£o")
    fig_map, df_points = create_trajectory_map(dataset.trajs, dataset.labels, sample_size=100)
    animated_fig = create_animated_trajectory_map(df_points)
    st.plotly_chart(animated_fig, use_container_width=True)
    st.subheader("Tr·ª±c quan h√≥a 3D qu·ªπ ƒë·∫°o b√£o")
    fig_3d = create_3d_trajectory_plot(dataset.trajs, dataset.labels, sample_size=20)
    st.plotly_chart(fig_3d, use_container_width=True)
    st.subheader("Bi·ªÉu ƒë·ªì v·∫≠n t·ªëc")
    fig_velocity = create_velocity_profile(dataset.trajs, dataset.labels, sample_size=10)
    st.plotly_chart(fig_velocity, use_container_width=True)

def show_real_input_prediction():
    st.title("D·ª± ƒëo√°n t·ª´ d·ªØ li·ªáu ƒë·∫ßu v√†o th·ª±c t·∫ø")
    st.write("T·∫£i l√™n file CSV ch·ª©a d·ªØ li·ªáu trajectory v·ªõi c√°c c·ªôt: t, longitude, latitude")
    uploaded_file = st.file_uploader("Ch·ªçn file CSV", type=["csv"])
    if uploaded_file is not None:
        try:
            df_input = pd.read_csv(uploaded_file)
            st.subheader("D·ªØ li·ªáu ƒë·∫ßu v√†o:")
            st.dataframe(df_input)
            # T·∫°o ƒë·ªëi t∆∞·ª£ng trajectory t·ª´ d·ªØ li·ªáu CSV
            traj_input = type("Trajectory", (object,), {})()
            traj_input.t = df_input["t"].values
            traj_input.r = df_input[["longitude", "latitude"]].values
            # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu trajectory th√†nh vector ƒë·∫∑c tr∆∞ng b·∫±ng featurizer c·ªßa m√¥ h√¨nh
            features = st.session_state.processor.model.featurizer.transform(traj_input)
            prediction = st.session_state.processor.model.predict([features])[0]
            st.success(f"D·ª± ƒëo√°n lo·∫°i b√£o: {prediction}")
            fig, _ = create_trajectory_map([traj_input], [prediction], sample_size=1)
            st.plotly_chart(fig, use_container_width=True)
        except Exception as e:
            st.error(f"L·ªói x·ª≠ l√Ω d·ªØ li·ªáu ƒë·∫ßu v√†o: {e}")

# --- H√†m ch√≠nh ---
def main():
    st.sidebar.title("Ph√¢n t√≠ch b√£o")
    st.sidebar.header("D·ªØ li·ªáu")
    if st.sidebar.button("Load D·ªØ li·ªáu B√£o"):
        with st.spinner("ƒêang load d·ªØ li·ªáu b√£o..."):
            dataset = load_data()
            st.sidebar.success(f"ƒê√£ load {len(dataset.trajs)} trajectory")
    if st.session_state.data_loaded:
        if st.sidebar.button("Tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng"):
            with st.spinner("ƒêang tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng..."):
                features_df = extract_features()
                st.session_state.processor.features_df = features_df
                st.sidebar.success(f"ƒê√£ tr√≠ch xu·∫•t ƒë·∫∑c tr∆∞ng t·ª´ {len(features_df)} trajectory")
        if st.session_state.features_extracted and st.sidebar.button("Hu·∫•n luy·ªán m√¥ h√¨nh"):
            with st.spinner("ƒêang hu·∫•n luy·ªán m√¥ h√¨nh..."):
                model_results = train_model()
                st.sidebar.success(f"M√¥ h√¨nh ƒë√£ hu·∫•n luy·ªán v·ªõi ƒë·ªô ch√≠nh x√°c: {model_results['report']['accuracy']:.4f}")
    st.sidebar.header("ƒêi·ªÅu h∆∞·ªõng")
    page = st.sidebar.radio(
        "Ch·ªçn m·ª•c",
        ["Trang ch·ªß", "Tr√¨nh duy·ªát qu·ªπ ƒë·∫°o", "Ph√¢n t√≠ch ƒë·∫∑c tr∆∞ng", "M√¥ h√¨nh d·ª± ƒëo√°n", "So s√°nh qu·ªπ ƒë·∫°o", "Tr·ª±c quan h√≥a n√¢ng cao", "T√°c ƒë·ªông b√£o", "D·ªØ li·ªáu ƒë·∫ßu v√†o th·ª±c t·∫ø", "V·∫Ω qu·ªπ ƒë·∫°o ƒë·ªÉ d·ª± ƒëo√°n"]
    )
    if page == "Trang ch·ªß":
        show_home_page()
    elif page == "Tr√¨nh duy·ªát qu·ªπ ƒë·∫°o":
        show_trajectory_explorer()
    elif page == "Ph√¢n t√≠ch ƒë·∫∑c tr∆∞ng":
        show_feature_analysis()
    elif page == "M√¥ h√¨nh d·ª± ƒëo√°n":
        show_prediction_model()
    elif page == "So s√°nh qu·ªπ ƒë·∫°o":
        show_trajectory_comparison()
    elif page == "Tr·ª±c quan h√≥a n√¢ng cao":
        show_advanced_visualizations()
    elif page == "T√°c ƒë·ªông b√£o":
        show_hurricane_impact()
    elif page == "D·ªØ li·ªáu ƒë·∫ßu v√†o th·ª±c t·∫ø":
        show_real_input_prediction()
    elif page == "V·∫Ω qu·ªπ ƒë·∫°o ƒë·ªÉ d·ª± ƒëo√°n":
        show_drawing_prediction()

if __name__ == "__main__":
    main()
